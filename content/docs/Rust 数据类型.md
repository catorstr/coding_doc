# 基本数据类型

Rust 是一个静态数据类型的语言，这意味着在编译时它就要知道变量的类型。

Rust 包含四种基本数据类型分别为：整形、浮点型、布尔型、字符型。

Rust语言有一组关键字，这些关键字只保留给该语言使用，就像在其他语言中一样。请记住，您不能使用这些词作为变量或函数的名称。大多数关键字都有特殊的含义，您将在Rust程序中使用它们来完成各种任务;少数关键字目前还没有与之相关的功能，但已预留给将来可能添加到Rust中的功能。

Rust中的每个值都属于特定的数据类型，这告诉Rust指定了什么类型的数据，这样它就知道如何处理这些数据。我们将研究两种数据类型子集:scalar and compound(标量和复合)。
请记住，Rust是一种静态类型语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以推断出什么类型，我们要使用的基础上的价值和我们如何使用它，在案件时，许多类型是可能的。例如，当我们在"比较猜测和密码"一节中使用parse将String转换为数值类型时，我们必须添加一个类型注释，如下所示:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

如果我们不添加前面代码中所示的:u32类型注释，Rust将显示以下错误，这意味着编译器需要我们提供更多信息来确定我们想要使用哪种类型:

```bash
 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = "42".parse().expect("Not a number!");
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
```

#### 标量类型

标量类型表示单个值。Rust有四种主要的标量类型:整数、浮点数、布尔和字符。您可能认识到这些来自其他编程语言的让我们来看看Rust是如何工作的。

#### 整型

整数是没有分数成分的数字。我们在第2章中使用了一种整型，u32类型。这个类型声明表明它所关联的值应该是一个占用32位空间的无符号整数(有符号整数类型以i而不是u开始)。

Rust 里的整型又分为带符号的整型（signed）和非带符号整型（unsigned），即有符号整型与无符号整型，两者之间的区别是数字是否是负数。带符号整型的安全存储范围为-(2^(n-1)n)到2^(n-1)-1，n 就是下面的长度。

非带符号整型的安全存储范围为 0 到2^(n-1)-1。isize 和 usize 是根据系统架构决定的，例如带符号整型，如果系统是 64 位，类型为 i64，如果系统是 32 位，类型为 i32。So an `i8` can store numbers from -(2 ^7^ ) to 2^7^ - 1, which equals -128 to 127.


| 长度    | 带符号整型 | 非带符号整型 |
| ------- | ---------- | ------------ |
| 8-bit   | i8         | u8           |
| 16-bit  | i16        | u16          |
| 32-bit  | i32        | u32          |
| 64-bit  | i64        | u64          |
| 128-bit | i128       | u128         |
| arch    | isize      | usize        |

此外，isize和usize类型取决于运行程序的计算机的体系结构，在表中用“arch”表示:如果是64位体系结构，则为64位;如果是32位体系结构，则为32位。

注意，可以是多个数值类型的数字文字允许使用类型后缀(如57u8)来指定类型。数字文字也可以用 _ 作可视分隔符，以使数字更容易阅读，例如1_000。它的值将与您指定的1000相同。


| Number literals    | Example         |
| ------------------ | --------------- |
| Decimal            | `98_222`      |
| Hex                | `0xff`        |
| Octal              | `0o77`        |
| Binary             | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |

那么如何知道使用哪种类型的整数呢?如果您不确定，Rust的默认值通常是很好的开始:整数类型默认为i32。使用isize或usize的主要情况是在索引某种集合时。

#### 整数溢出

假设您有一个类型为us的变量，它可以容纳0到255之间的值。如果尝试将变量更改为该范围以外的值(例如256)，则会发生整数溢出，这可能导致以下两种行为之一。在调试模式下编译时，RUST包括检查整数溢出，如果发生此行为，则会导致程序在运行时恐慌。当程序退出时，铁锈使用了恐慌这个术语，我们将在“惊慌中无法恢复的错误”中更深入地讨论恐慌。第九章的一节。
当您使用--release标志在release模式下编译时，Rust不包含导致崩溃的整数溢出检查。相反，如果溢出发生，Rust执行二的补码包装。简而言之，大于类型所能容纳的极大值的值将被“环绕”到类型所能容纳的最小值。以u8为例。值256变为0，值257变为1，依此类推。程序不会死机，但变量的值可能不是您期望的值。依赖整数溢出的包装行为被认为是一个错误。

```rust
fn main() {
    let num = 1;//声明了一个不可变的变量，并将它赋值为1，由于在vscode安装了rust插件，语法被自动补全了(自动类型推断)，我写的其实是：let num =1；
    //num =2 //这里报错了，说明我们用let 声明的num是不可变的变量，只能对它进行一次赋值，
    /* 
变量
Rust 使用 let 声明一个变量，通常来说变量将是可变的，但是在 Rust 中默认设置的变量是预设不可变的，在Rust中，变量在默认情况下是不可变的这意味着一旦我们给变量一个值，这个值就不会改变。这也是 Rust 推动你能充分利用其提供的安全性来写程序的方式之一，Rust 中鼓励你多多使用不可变的，当然如果你明确知道该变量是可变得，也是可以的。
rust和go一样声明的变量必须使用，不然会报错，这也许是新型语言的一个特点吧
    */
    println!("不可变的变量num = {}",num); //注意，println! 后面加上了符号 ! 并不是一个函数，而是一个宏。{}可以理解为一个格式化方式
    //为了使变量具有可变性，我们在变量名前添加mut:
    let mut num2 = 2; //在变量名称前加上 mut 关键字，表明该变量是可变的。
    num2 = 3; //这时候对变量进行赋值，就不会报错了
    println!("可变的变量num2 = {}",num2);
    let x = 5;
    println!("The value of x is: {x}"); //The value of x is: 5
/*
常量
常量使用 const 声明，之后是不可变的，在声明时必须指定变量类型，这也是与 let 的不同，还需注意的是常量名称一定要大写，否则编译阶段也是会报错的。
Rust对常量的命名习惯是在单词之间使用大写字母加下划线。
常量在声明常量的作用域中，在程序运行的整个时间内都是有效的。
将整个程序中使用的硬编码值命名为常量，有助于将该值的含义传达给代码的未来维护者。如果将来需要更新硬编码的值，那么在代码中只需要更改一个地方也很有帮助.
 */
    const NUM:i8 = 1;
    println!("常量NUM:={}",NUM);
/*
 Shadowing  遮蔽
您可以声明一个新变量，其名称与前一个变量相同。Rustaceans说，第一个变量被第二个变量所遮蔽，这意味着第二个变量是编译器在使用变量名称时所看到的，第二个变量在第一个变量的阴影下，将变量名的任何用法保留到自己，直到它本身被遮蔽或作用域结束为止。通过使用相同变量的名称并重复LET关键字的使用，我们可以对变量进行阴影，如下所示：
 */
let x =5;
let x =x+1; //6
 {
        let x = x * 2; //12
        println!("The value of x in the inner scope is: {x}"); //12
  }

    println!("The value of x is: {x}"); //6
//这哥例子在{}中，x的值变为12，但当{}的作用域结束后，x的值是6，回到了另外的作用域了
/*
一个变量只有在其作用域内是生效的。下例，变量 y 在花括号内即它的块级作用域内是有效的，当离开花括号如果想在外部打印，会报 cannot find value y in this scope 错误。
*/
 let x = 1;
    {
        let y = 2; // y 在此处开始有效
        println!("y {}", y);
        println!("x is {}; y={}", x, y);
    } // 此作用域结束，y 不再有效
   // println!("x {} y {}", x, y);//报错
    println!("x={}", x);//x=1

}
shadowing 不同于将一个变量标记为mut，因为如果我们不小心尝试给这个变量重新赋值而没有使用let关键字，我们会得到一个编译时错误。通过使用let，我们可以对一个值执行一些转换
但在这些转换完成后，变量将保持不变。
mut和shadowing的另一个区别是，当我们再次使用let关键字时，实际上是创建了一个新的变量，因此我们可以改变值的类型，但重新使用相同的名称。例如，假设我们的程序要求用户通过输入空格字符来显示文本之间需要多少空格，然后我们希望将输入存储为一个数字:
    let spaces = "   ";
    let spaces = spaces.len();
    println!("空格数量={spaces}");//空格数量=3
    /*
    第一个空格变量是字符串类型，第二个空格变量是数字类型。因此，隐藏使我们不必使用不同的名称如spaces str和spaces num;相反，我们可以重用更简单的spaces名称。但是，如果我们尝试使用mut，我们会得到一个编译时错误:
     */
    //let mut spaces = "   ";
   // spaces = spaces.len();
   /*
   let mut spaces = "   ";
   |                      ----- expected due to this value
   spaces = spaces.len();
   |              ^^^^^^^^^^^^ expected `&str`, found `usize`
    */


```

#### 浮点型

Rust也有两种浮点数的基本类型，它们是带小数点的数字。Rust的浮点类型是32和f64，它们的大小分别是32位和64位。默认类型为f64，因为在现代CPU上，它的速度与32大致相同，但精度更高。所有浮点类型都是有符号的。浮点数按照IEE-754标准表示。f32类型是单精度浮点数，而f64具有双精度

```go
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
    println!("x: {}, y: {}", x, y); // x: 2, y: 3
}
```

#### 布尔型

和大多数编程语言一样，Rust 中的布尔型包含两个值：true 和 false。

```go
fn main() {
    let x = true; // bool
    let y: bool = false; // bool
}
```

#### 字符型

Rust的char类型是语言中最原始的字母类型。
注意，我们用单引号指定char字面量，而不是使用双引号的字符串字面量。rust的char类型大小为4个字节表示一个unicode标量值，这意味着它可以表示的不仅仅是asci。重音字母、中文、日文和韩文字符emoii和零宽度空格都是Rust中有效的char值。Unicode标量值的范围从U+0000到U+D7FF和U+Eooe到U+10FF。但是，“字符”在Unicode中并不是一个真正的概念，所以您对“字符”的直觉可能与Rust中的字符不匹配。我们将在第8章的“用字符串存储UTF-8编码的文本”中详细讨论这个主题。

```go

fn main() {
    let x = 'x';
    let y = '????';
    println!("x: {}, y: {}", x, y); // x: x, y: ????
}
```

### 复合类型

复合类型可以组合多个数值为一个类别，复合类型包含两种：元组（tuples）和数组（arrays）。

#### 元组

元组是将多个不同数值组合为一个复合类型的常见方法。元组有一个固定的长度:一旦声明，它们的大小就不能增长或收缩。
我们通过在括号内编写一个逗号分隔的值列表来创建一个元组。元组中的每个位置都有一个类型，元组中不同值的类型不必相同。

我们通过**解构**的方式，分别从声明的元组中取出数据，如下例所示：

```go
fn main() {
    let tup: (i32, f64, char) = (1, 1.01, '????');
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z); // x: 1, y: 1.01, z: ????
}
```

除此之外我们还可通过数值的索引来访问元组中的数据。

```go
fn main() {
    let tup: (i32, f64, char) = (1, 1.01, '????');
    let x = tup.0;
    let y = tup.1;
    let z = tup.2;
    println!("x: {}, y: {}, z: {}", x, y, z); // x: 1, y: 1.01, z: ????
}
```

#### 数组

与元组不同的是数组中的所有元素类型必须一致，Rust 中的 Array 与其它语言不太一样，因为其 Array 的长度是固定的和元组一样。

```go
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    println!("a[0]: {}, a[4]: {}", a[0], a[1]); // a[0]: 1, a[4]: 2
let a = [3; 5];
//名为a的数组将包含5个元素，这些元素最初都将被设置为值3。这和写让a=[3，3，3，3，3]是一样的，只是用了一种更简洁的方式。

/*
。当您尝试使用索引访问一个元素时，Rust将检查您指定的索引是否小于数组长度。如果指数大于或等于长度，Rut会恐慌。这种检查必须在运行时进行.
*/
}
```

```rust
fn main() {
//声明一个元组，并初始化它
let tup:(i32,char,f64) = (1,'H',1.25); //char 字符类型用''
//通过下标访问元组
println!("tup.0 = {},tup.1 ={},tup.2 ={}",tup.0,tup.1,tup.2);
let (i,c,f) =tup;//解构，即拆分元组的数据，然后分别赋值到变量i，c,f中
println!("i = {},c ={},f= {}",i,c,f);

//声明一个数据类型为i32，长度为5的数组，并赋值
let arr:[i32;5] = [1,2,3,4,5];
//通过下标访问数组
println!("arr[0]={},arr[4]={}",arr[0],arr[4]);
/*
tup.0 = 1,tup.1 =H,tup.2 =1.25
i = 1,c =H,f= 1.25
arr[0]=1,arr[4]=5
 */
}

```
